package contractcourt

import (
	"testing"

	"github.com/lightningnetwork/lnd/channeldb"
	"github.com/lightningnetwork/lnd/invoices"
	"github.com/lightningnetwork/lnd/lntypes"
	"github.com/lightningnetwork/lnd/lnwire"
	"github.com/stretchr/testify/require"
)

type notifyExitHopData struct {
	payHash       lntypes.Hash
	paidAmount    lnwire.MilliSatoshi
	hodlChan      chan<- interface{}
	expiry        uint32
	currentHeight int32
}

type mockRegistry struct {
	notifyChan       chan notifyExitHopData
	notifyErr        error
	notifyResolution invoices.HtlcResolution

	cancelChan chan lntypes.Hash
	cancelErr  error
}

func (r *mockRegistry) NotifyExitHopHtlc(payHash lntypes.Hash,
	paidAmount lnwire.MilliSatoshi, expiry uint32, currentHeight int32,
	circuitKey channeldb.CircuitKey, hodlChan chan<- interface{},
	payload invoices.Payload) (invoices.HtlcResolution, error) {

	r.notifyChan <- notifyExitHopData{
		hodlChan:      hodlChan,
		payHash:       payHash,
		paidAmount:    paidAmount,
		expiry:        expiry,
		currentHeight: currentHeight,
	}

	return r.notifyResolution, r.notifyErr
}

func (r *mockRegistry) HodlUnsubscribeAll(subscriber chan<- interface{}) {}

func (r *mockRegistry) LookupInvoice(lntypes.Hash) (channeldb.Invoice,
	error) {

	return channeldb.Invoice{}, channeldb.ErrInvoiceNotFound
}

// Cancel invoice mocks canceling an invoice with the registry, sending the
// hash into our cancel channel and returning the error that we configured the
// mock with.
func (r *mockRegistry) CancelInvoice(hash lntypes.Hash) error {
	r.cancelChan <- hash

	return r.cancelErr
}

// assertCancelInvoice asserts that we have canceled an invoice with the hash
// provided with our mock registry.
func (r *mockRegistry) assertCancelInvoice(t *testing.T,
	expected lntypes.Hash) {

	t.Helper()
	require.Equal(t, expected, <-r.cancelChan)
}
